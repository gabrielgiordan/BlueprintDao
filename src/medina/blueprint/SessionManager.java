/* Copyright (C) 2013 Gabriel Giordano
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. */
package medina.blueprint;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Map;

abstract class SessionManager
{

	private static final Map<Class<?>, Entity> entityMap;
	private static final Map<String, Map<String, Integer>> columnMap;

	static
	{
		entityMap = new HashMap<>();
		columnMap = new HashMap<>();
		
		Runtime.getRuntime().addShutdownHook(new Thread() {
			
			@Override
			public void run()
			{
				super.run();
				
				entityMap.clear();
				columnMap.clear();
				
				System.err.println
				(
					"\n	Clearing resources, closing manager."
				);
			}
			
		});
	}
	
	protected final Map<String, PreparedStatement> statementMap;
	protected final Connection connection;

	// Constructors____________________________________________________________________ //

	SessionManager(Connection connection)
	{
		this.connection = connection;
		statementMap = new HashMap<String, PreparedStatement>();
	}
	
	// Public Methods__________________________________________________________________ //
	
	public final static synchronized Entity getEntity(Class<?> clazz)
	{
		if (entityMap.containsKey(clazz))
		{
			return entityMap.get(clazz);
		}

		Entity entity = new Entity(clazz);
		entityMap.put(clazz, entity);

		return entity;
	}

	// Package Methods_________________________________________________________________ //
	
	final static synchronized Map<String, Integer> getColumnMapping(ResultSet resultSet, String sql)
			throws SQLException
	{
		if (columnMap.containsKey(sql))
		{
			return columnMap.get(sql);
		}

		final Map<String, Integer> columnMapping = new HashMap<>();

		ResultSetMetaData metaData = resultSet.getMetaData();

		int count = metaData.getColumnCount() + 1;
		while (count-- > 1)
		{
			columnMapping.put(metaData.getColumnName(count).toLowerCase(), count);
		}

		SessionManager.columnMap.put(sql, columnMapping);

		return columnMapping;
	}
	
	private final PreparedStatement getAutoGeneratedKeyStatement(String sql) throws SQLException
	{
		
		final PreparedStatement statement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
		
		statementMap.put(sql, statement);
		
		return statement;
	}
	
	final PreparedStatement getAutoGeneratedKeyStatement(String sql, String[] columns) throws SQLException
	{	
		System.err.println("   SQL> " + sql);
		
		if (statementMap.containsKey(sql))
		{
			return statementMap.get(sql);
		}
		
		if(columns == null)
		{
			return getAutoGeneratedKeyStatement(sql);
		}
		
		final PreparedStatement statement = connection.prepareStatement(sql, columns);
		
		statementMap.put(sql, statement);
		
		return statement;
	}
	
	final PreparedStatement getStatement(String sql) throws SQLException
	{
		System.err.println("   SQL> " + sql);
		
		if (statementMap.containsKey(sql))
		{
			return statementMap.get(sql);
		}

		final PreparedStatement statement = connection.prepareStatement
		(
			sql, 
			ResultSet.TYPE_FORWARD_ONLY, 
			ResultSet.CONCUR_READ_ONLY,
			ResultSet.CLOSE_CURSORS_AT_COMMIT
		);
		
		statementMap.put(sql, statement);

		return statement;
	}

}
